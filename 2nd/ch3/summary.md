# 3장 파드
## 파드 소개
파드의 개념
- 함께 배치된 컨테이너 그룹
- 쿠버네티스의 기본 빌딩 블록. 파드의 컨테이너는 같은 워커노드에서 실행된다

파드가 필요한 이유(여러 프로세스를 실행하는 단일 컨테이너 보다 다중 컨테이너가 좋은 이유)
- 컨테이너는 단일 프로세스를 실행하는 것을 목적으로 설계 됐다. 
- 단일 컨테이너에서 관련 없는 프로세스를 실행하는 경우 프로세스 관리, 로그 관리가 모두 사용자 책임이다. 프로세스의 재 시작 매커니즘도 관린해야 한다. 

파드의 컨테이너 격리
- 컨테이너 모음을 이용해서 연관된 프로세스를 함께 실행시키고, 단일 컨테이너에서 실행되는 것처럼 환경을 제공한다
- 파드 안의 컨테이너가 동일한 네임스페이스를 공유하도록 도커를 설정한다. (예: 같은 호스트 이름과 네트워크 인터페이스 공유)
- 파일시스템은 컨테이너 이미지에서 나오기 때문에 다른 컨테이너와 분리된다. 볼륨을 이용해서 컨테이너가 디렉터리를 공유하는 것은 가능하다.

컨테이너간 네트워크
- 동일한 네트워크 네임스페이스에서 실행되기 때문에 동일한 IP와 포트를 공유한다. 파드안의 각 컨테이너에서 실행중인 프로세스가 포트가 충돌되지 않도록 주의해야한다. 
- 파드끼리는 서로다른 포트 공간을 갖기 때문에 위 내용이 해당되지 않는다. 

파드간 네트워크
- 클러스터의 모든 파드는 하나의 플랫한 네트워크 주소 공간에 상주하고, 고유한 IP를 가진다.
- LAN에 있는 컴퓨터 간의 통신과 비슷하다. 파드끼리는 IP주소를 사용해서 접근하는 것이 가능하다. 

파드의 컨테이너 구성
- 모든 애플리케이션을 하나의 파드에서 구동하는 것 보다, 특정안 애플리케이션만을 호스팅하는 방향으로 구성한다. 
- 이유
   - 파드는 상대적으로 가볍기 때문에 오버헤드 없이 필요한 만큼 파드를 가질 수 있다. 예: 프론드엔드와 백엔드 시스템을 하나의 파드에서 실행해야할까? 
   - 노드가 2개 이상이라고 할 때 파드를 개별적으로 구성한다면 각각의 노드에 파드에 배치해서 컴퓨팅 리소스를 좀 더 효율적으로 사용할 수 있다
   - 스케일링
      - 파드는 스케일링의 기본 단위
      - 여러 시스템이 한개의 파드에 존재한다면 파드를 스케일링하면서 시스템들의 개별적 확장이 어렵다. 

파드에서 여러 컨테이너를 사용하는 경우
- 하나의 주요 프로세스와 하나 이상의 보완 프로세스로 구성된 경우
- 예: 
   - 주 컨테이너: 웹 서버
   - 보조 컨테이너: 주기적으로 컨텐츠를 받아서 서버의 디렉터리에 저장
      - 그 외: 로그 수집기, 데이터 프로세서, 통신 어댑터 등 
- 결정에 대한 질문
   1. 컨테이너를 함께 실행해야하는가? 서로 다른 호스트에서 실행될 수 있는가?
   2. 여러 컨테이너가 모여 하나의 구성 요소를 나타내는가? 개별적인 구성요소인가?
   3. 컨테이너가 함께, 혹은 개별적으로 스케일링 되어야하는가?
   
## YAML 또는 JSON 디스크립터로 파드 생성
파드를 포함한 쿠버네티스 리소스 생성 방법
1. API 서버에 JSON 또는 YAML 매니페스트를 전송해서 생성
   - 버전 관리 시스템을 통해서 관리할 수 있다
2. `kubectl run` 명령어를 사용해서 생성 
   - 간단하지만, 제한된 속성 집합만을 설정할 수 있다

파드 생성
- 매니페스트: kubia-manual.yaml
   ```yaml
  apiVersion: v1              # 쿠버네티스 API 버전
  kind: Pod                   # 리소스 종류
  metadata:                   # 이름, 네임스페이스, 레이블 및 파드에 관한 정보를 설정
    name: kubia-manual         # 파드 이름
  spec:                       # 파드 컨테이너, 볼륨, 기타 데이터 등 파드 자체에 대한 명세  
    containers:                # 컨테이너 이미지 설정
    - image: go1323/kubia_2    # 이미지 경로
      name: kubia              # 컨테이너 이름
      ports:
      - containerPort: 8080     # 애플리케이션 수신 포트
        protocol: TCP
   ```
- 생성 커맨드
   ```
   kubectl create -f <<filename>>
   예: kubectl create -f kubia-manual.yaml
   ```
- 파드 조회
   ```
   // 전체 파드 조회
   kubectl get pods

   // yaml 형식으로 파드 보기
   kubectl get pod <<pod name>> -o yaml

   // json 형식으로 파드 보기
   kubectl get pod <<pod name>> -o json
   ```

애플리케이션 로그 보기
- 컨테이너 런타임(도커)은 출력 스트림을 파일로 전달하고, 조회할 수 있는 기능을 제공한다. 
- 파드가 삭제되면 로그도 같이 삭제되기 때문에, 중앙집중된 로깅 시스템을 구축해서 파드가 삭제되어도 로그를 볼 수 있도록 구성해야한다.
- 도커 
   ```
   docker logs <<container id (또는 이름)>>
   ```
- 쿠버네티스
   ```
   // 파드의 로그
   kubectl log <<pod name>>

   // 개별 컨테이너의 로그
   kubectl logs <<pod name>> -c <<container name>>
   ```

포트 포워딩을 이용한 파드 테스트 및 디버깅
- 파드는 서비스를 이용해서 접속하는 것이 일반적인 방법이나, 테스트 또는 디버깅 목적으로 포트 포워딩을 이용해서 파드로 서비스 없이 요청을 보낼 수 있다
- 커맨드
   ```
   kubectl port-forward <<pod name>> 8888:8080
   ```

## 레이블을 이용한 파드 구성
배경
- 파드로 애플리케이션을 관리하기 시작하면서 파드의 수가 점점 많아진다. 이에 따라 파드를 집합 개념으로 관리하고 싶은 니즈가 생긴다.

레이블
- 파드와 다른 쿠버네티스 리소스를 조직화 할 수 있는 단순하면서 강력한 기능
- 키-밸류 쌍을 이용해서 레이블을 구성하고, 레이블 셀렉터를 이용해서 리소스를 선택할 수 있다.
- 레이블 키가 리소스 내에서 고유하다면 하나 이상의 레이블을 가질 수 있다.

레이블을 지정해서 파드를 생성
- 디스크립터
   ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: kubia-manual-v2
    labels:                    ## 레이블 설정
      creation_method: manual
      env: prod
  spec:
    containers:
    - image: go1323/kubia_2
      name: kubia
      ports:
      - containerPort: 8080
        protocol: TCP
        
   ```
- 레이블 조회
   ```
   // 레이블을 포함한 파드 조회
   kubectl get pods --show-labels

   // 레이블을 칼럼으로 하는 파드 조회
   kubectl get pods -L <<,로 구분되는 레이블 키 정보 입력>>
   ```
- 레이블 수정
   ```
   kubectl label pods <<pod name>> <<레이블 키>>=<<레이블 밸류>>
   예: k label pods kubia-manual creation_method=manual  

   // 덮어쓰기
   kubectl label pods <<pod name>> <<레이블 키>>=<<레이블 밸류>> --overwrite
   ```

## 레이블 셀렉터
레이블 셀렉터를 이용한 파드 나열
- 커맨드
   ```
   // 키,밸류를 이용한 조회
   kubectl get pods -l <<레이블 키>>=<<레이블 밸류>>

   // 밸류는 상관없이 키만 가지고 있는 파드 조회
   kubectl get pods -l <<레이블 키>>

   // 밸류는 상관없이 키를 가지고 있지 않은 파드 조회
   kubectl get pods -l '<<!레이블 키>>'

   // 특정 키/밸류를 포함하는 있는 파드 조회
   kubectl get pods -l '<<레이블 키>> in (<<,로 구분되는 레이블 밸류>>)'

   // 키, 밸류를 ','로 구분해서 2개 이상의 조건을 설정하는 것도 가능하다
   예: k get pods -l creation_method=manual,env=prod
   ```

## 레이블 셀렉터를 이용한 파드 스케쥴링 제한
배경
- 레이블 셀렉터를 이용해서 특정 노드에 파드가 스케쥴링 되도록 설정할 수 있다
- 쿠버네티스의 경우 애플리케이션으로부터 특정 인프라를 노출해야하는 문제가 발생할 수 있는데 (쿠버네티스를 사용하면서 인프라는 쿠버네티스에 맡기는 컨셉이 있기 때문에), 특정 노드를 지정하는 대신 요구사항을 기술하고 쿠버네티스가 해당 요구사항을 만족하는 노드를 선택하도록 하 수 있다.

특정 워커노드에 컨테이너 배치
1. 워커노드에 레이블 설정
   ```
   kubectl label node <<node name>> <<레이블 키>>=<레이블 밸류>>
   예: k label node multinode-demo-m02 gpu=true 
   ```
2. 특정 노드에 파드 스케쥴링
   ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: kubia-gpu
    spec:
      nodeSelector:     # nodeSelector를 통해서 레이블 값 입력
        gpu: "true"
      containers:
      - image: go1323/kubia_2
        name: kubia
        ports:
        - containerPort: 8080
          protocol: TCP
   ```
   - 맞는 노드가 없으면 pending 상태로 남는다

## 어노테이션
개념
- 키-값 쌍으로 레이블과 비슷하지만 식별 정보를 갖지는 않는다. 
- 레이블은 오브젝트를 묶는데 사용할 수 있지만, 어노테이션은 셀렉터가 없다. 

주로 사용
- 파드나 다른 API 오브젝트에 설명을 추가하는데 사용된다. 이를 통해서 클러스터를 사용하는 모든 사람이 오브젝트에 대한 정보(예: 작업자)를 신속하게 찾아볼 수 있다.
- 어노테이션은 다른 도구, 라이브러리에 의해서 덮어써질 수 있기 때문에, 고유한 접두사를 사용해서 관리하는 것이 권장된다.

어노테이션 조회, 추가 및 수정
- 조회
   ```
   kubectl get pod <<pod name>> -o yaml
   kubectl describe pod <<pod name>>

   // 결과
   Annotations:  mycompany.com/testannotation: hello world
   ```
- 추가
   ```
   kubectl annoate pod <<pod name>> <<annotation>> 
   예: k annotate pod kubia-manual mycompany.com/testannotation="hello world"             
   ```

## 네임스페이스
개념
- 쿠버네티스의 오브젝트 범위를 제공
- 리눅스의 네임스페이스와는 다르다

배경
- 레이블을 이용하면 오브젝트를 그룹핑할 수 있는데, 오브젝트 그룹은 서로 겹쳐질 수 있다.
- 오브젝트를 겹차지 않는 그룹으로 분할해서 관리학 위해서 등장했다. 분리되어 있기 때문에 서로 다른 네임스페이스에는 같은 이름의 오브젝트 있을 수 있다.

사용 용도
- 멀티테넌트 환경처럼 리소스를 분리하는데 사용된다.
   - 리소스를 프로덕션, 개발, QA 환경으로 나누어서 사용하고자 할 때. 
   - 사용자별로 리소스를 관리하고자 할 때.
   - 예: 사내의 개발 환경도 개발 환경이 네임스페이스로 분리되어 있다. 
- 특정 사용자가 지정된 리소스에 접근할 수 있도록 허용하거나, 개발 사용자가 사용할 수 있는 리소스를 제한하는 데에도 사용된다. 
- 대부분 리소스는 네임스페이스에 속하지만 노드는 네임스페이스에 얽매이지 않는다. 

네임스페이스 조회 및 생성
- 조회
   ```
   // 네임스페이스 리스트 조회
   kubectl get ns

   // 네임스페이스에 있는 파드 리스트 조회
   kubectl get pods --namespace <<네임스페이스>>
   ```
- 생성
  ```yaml
  apiVersion: v1
  kind: Namespace
  metadata:
    name: custom-namespace
  ```
  - `kubectl create namepsace <<네임스페이스>>`로도 생성할 수 있다.

다른 네임스페이스에 파드를 생성하기
1. metadata 섹션에 `namespace: <<네임스페이스>>` 를 넣는 방법
2. '`kubectl create -f <<생성 파일>> -n <<네임스페이스>>`'로 생성
- 네임슾이스를 지정하지 않으면 kubectl 컨텍스트에 지정된 default 네임스페이스에 생성된다

kubectl 컨텍스트
- 개념: kubectl 명령을 수행할 때 사용할 클러스터, 사용자, 디폴트 네임스페이스를 묶어주는 정보
- 조회: `kubectl config get-contexts`
- 설정 저장 경로: ~/.kube/config
- 컨텍스트 전환
   - `kubectl config use-context <<context name>>`
   - `kubectx <<컨텍스트 이름>>`

## 파드의 중지와 제거
파드 삭제
- 파드를 삭제하면서 쿠버네티스는 파드 안에 있는 모든 컨테이너를 종료하도록 지시한다 -> SIGTERM 신호를 보내고 지정된 시간(기본 30초)를 기다린다
- 시간 내에 종료되지 않으면 SIGKILL 신호를 보내서 종료시킨다

커맨드 정보
```
// 이름으로 삭제
kubectl delete pod <<pod name>>
kubectl delete pod <<pod name>> <<pod name2>> <<pod name n>> 

// 레이블 셀렉터를 이용한 삭제
kubectl delete pods -l <<레이블 키>>=<<레이블 밸류>>

// 네임스페이스를 이용한 삭제 - 네임스페이스를 삭제하면 파드가 함께 삭제된다
kubectl delete ns <<네임스페이스>>

// 전체 파드 삭제
kubectl delete pods --all

// 네임스페이스에서 거의 모든 리소스 삭제 (시크릿 등의 특정 리소스는 명시적으로 삭제해야한다)
kubectl delete all --all
```