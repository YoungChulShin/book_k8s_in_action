# 1장. 쿠버네티스 소개
등장 배경 및 기능
- 모놀리스 레거시 애플리케이션이 점차 마이크로서비스라는 더 작은 구성요소로 세분화되고 있다
- 배포 가능한 구성 요소가 많아지고 데이터 센터의 규모가 커지면서 전체 시스템을 원활하게 구성, 관리, 유지하는 일이 점점 어려워졌다
- 쿠버네티스를 이용하면 개발자가 운영 팀의 도움 없이도 자신의 애플리케이션을 원하는 만큼 자주 배포할 수 있도록 한다
## 쿠버네티스 같은 시스템이 필요한 이유
1. 모놀리스 애플리케이션에서 마이크로서비스로 전환
   - 모놀리스 애플리케이션은 일부분을 수평적으로 확장하기가 매우 어렵거나 불가능하다
   - 모놀리스를 마이크로서비스라는 독립적 배포/개발/실행 환경으로 분리하면 다른 서비스에 영향을 덜 주면서 배포할 수 있다
   - 마이크로서비스는 여러 서비스가 함께 작업을 수행하기 때문에 배포할 때 전체가 하나의 시스템처럼 동작하도록 별도의 구성이 필요하다. 
2. 애플리케이션에 일관된 환경 제공
3. 지속적인 배포로 전환
   - 데브옵스
      - 과거의 경우 개발팀의 업무는 애플리케이션을 개발/배포를 관리하며 운영팀에게 넘겨주는 것이었다. 
      - 하지만 이제는 개발 팀이 애플리케이션을 배포하고 관리하는 것이 더 낫다는 것을 깨딸았는데, 이는 모든 팀이 전체 프로세스에서 협업해야 한다는 것을 의미한다
      - 최신 버전의 애플리케이션을 더 자주 릴리즈하려면 배포 프로세스를 간소화해야 하는데, 제일 좋은 방법은 개발자가 직접 배포하는 것이다
      - 이 과정에서 개발자가 인프라를 잘 알지 못하더라도 운영팀을 거치지 않고 배포할 수 있는 것이 가장 이상적이다

## 컨테이너 기술 소개
### 컨테이너의 이해
컨테이너
- 동일한 호스트 시스템에 여러 개의 서비스를 실행할 수 있다
- 동시에 서로 다른 환경을 만들어줄 뿐만 아니라, 가상머신에 비해서 오버헤드가 적다

가상머신과의 비교
- 가상머신이 호스트 OS 위에 하이퍼바이저와 게스트 OS가 있다. 그 위에서 앱이 수행된다.
- 컨터이너는 호스트 OS와 동일한 커널에서 시스템 콜이 수행된다.

컨테이너 격리 메커니즘
1. 리눅스 네임스페이스로 격리
   - 기본적으로 각 리눅스 시스템에는 하나의 네임스페이스가 있고, 추가 네임스페이스를 구성할 수도 있다
   - 프로세스를 실행할 때 해당 네임스페이스 중 하나에서 프로세스를 실행한다
   - 프로세스는 동일한 네임스페이스에 있는 리소스만 볼 수 있다
2. 프로세스의 가용 리소스를 제한
   - 프로세스의 리소스 사용을 제한해서, 설정된 양 이상의 CPU, 메모리, 네트워크 대역폭등을 사용할 수 없게 한다

### 도커 컨테이너 플랫폼
도커
- 컨테이너를 여러 시스템에 쉽게 이식 가능하게 하는 최초의 컨테이너 시스템
- 애플리케이션, 라이브러리, 종속성, 운영체제 파일시스템까지 패키징 한다
- 가상머신을 사용해 애플리케이션을 격리하는 대신, 리눅스 컨테이너 기술로 가상머신과 동일한 수준의 격리를 제공한다

도커 개념
- 이미지
   - 애플리케이션과 해당 환경을 패키지화 한 것
   - 애플리케이션이 사용할 수 있는 파일 시스템과 이미지가 실행될 때 실행돼야 하는 실행파일 경로와 같은 메타데이터가 포함되어 있다
- 레지스트리
   - 도커 이미지를 공유활 수 있는 저장소
- 컨테이너
   - 도커 기반 컨테이너 이미지에서 생성된 리눅스 컨테이너

이미지 레이어
- 모든 도커 이미지는 다른 이미지 위에 빌드되며 두 개의 다른 이미지는 기본 이미지로 동일한 부모 이미지를 사용할 수 있기 때문에 동일한 레이어가 포함될 수 있다
- 레이어를 통해서 배포 속도을 올리고, 스토리지 공간을 줄이는데 도움이 된다

## 쿠버네티스 소개
쿠버네티스 기원
- 구글에서 2014년 오픈소스 시스템으로 쿠버네티스를 출시

쿠버네티스 개념
- 쿠버네티스는 컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템이다
- 쿠버네티스를 사용하면 모든 노드가 하나의 거대한 컴퓨터인 것처럼 수천 대의 컴퓨터 노드에서 애플리케이션을 실행할 수 있다
- 쿠버네티스는 클러스터의 운영체제로 생각할 수 있다
   - 서비스 디스커버리, 스케일링, 로드밸런싱, 자가 치유, 리더 선출 같은 것들이 포함되어 있다
   - 개발자는 애플리케이션의 기능을 구현하는데 집중하고, 애플리케이션을 인프라와 통합하는 방법을 찾는데 드는 시간을 낭비하지 않아도 된다

아키텍처의 이해
![1-9](/images/1-9.png)
- 컨트롤 플레인
   - 클러스터를 제어하고 작동시킨다
   - API 서버는 사용자, 컨트롤 플레인 구성요소와 통신한다
   - 스케줄러는 애플리케이션의 배포를 담당한다
   - 컨트롤러 매니저는 구성 요소 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수헝한다
   - Etcd는 클러스 구성을 지속적으로 저장하는 분산데이터 저장소
- 노드
   - 구성요소
      - 컨테이너를 실행하는 도커
      - API 서버와 통신하고 노드의 컨테이너를 관리하는 Kubelet
      - 애플리케이션 구성 요소 간에 네트워크 트래픽을 로드밸런싱하하는 Kube-proxy

애플리케이션 실행
![1-10](/images/1-10.png)

쿠버네티스 사용 장점
- 애플리케이션 배포 단순화
   - 쿠버네티스는 모든 워커 노드를 하나의 배포 플랫폼으로 제공하기 때문에 애플리케이션 개발자는 자체적으로 애플리케이션 배포를 시작할 수 있으며, 클러스터를 구성하는 서버에 관해 알 필요가 없다
   - 몬질적으로 모든 노드는 애플리케이션이 해당 노드를 사용하기를 기다리는 하나의 컴퓨팅 리소스다
   - 특정 환경이 필요한 경우 개발자가 특정 환경을 지정해서 배포하는 것이 아니라, 쿠버네티스에 그 환경을 알려주는 방법을 처리 가능하다
- 쿠버네티스가 알아서 리소스 관리를 하기 때문에 하드웨어 활용도가 올라간다
- 자가 치유
   - 구성중인 노드를 모니터링하다가 장애가 발생하면 다른 노드로 스케줄링한다
- 오토 스케일링
